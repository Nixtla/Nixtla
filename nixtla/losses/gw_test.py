# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/losses__gw_test.ipynb (unless otherwise specified).

__all__ = ['Newey_West', 'GW_CPA_test', 'GW_test_p_values', 'plot_GW_test_p_values']

# Cell
import os
import numpy as np
from scipy.stats.distributions import chi2

# Cell
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

from matplotlib import rcParams
plt.rcParams['font.family'] = 'serif'

from matplotlib.colors import ListedColormap

# Cell
def Newey_West(Z, n_lags):
    """ Newey-West HAC estimator
    Parameters
    ----------
    Z: (n, k) ndarray
    n_lags: number of lags

    Returns
    -------
    omega_hat: Newey-West HAC estimator of the covariance matrix
    """

    assert n_lags > 0

    n, k = Z.shape

    Z = Z - np.ones((n, 1)) * np.mean(Z, axis=0)
    gamma = -999 * np.ones((n_lags, k))
    omega_hat = (1/n) * np.matmul(np.transpose(Z), Z)

    Zlag = np.array([np.pad(Z, ((i,0), (0,0)), mode='constant',
                            constant_values = 0)[:n]
                     for i in range(1, n_lags + 1)])
    gamma = (1/n) * (np.matmul(np.transpose(Z), Zlag) +
            np.matmul(np.einsum('ijk -> ikj', Zlag), Z))
    weights = 1 - np.array(range(1,n_lags + 1))/(n_lags + 1)
    omega_hat = omega_hat + \
                np.sum(gamma * np.expand_dims(weights,
                                              axis = (1,2)),
                                              axis = 0)
    return omega_hat

# Cell
def GW_CPA_test(loss1, loss2, tau, alpha=0.05,
                unconditional=True, verbose=True):
    """ Giacomini-White Conditional Predictive Ability Test
    Parameters
    ----------
    loss1, loss2: 1-D ndarray of length T
    tau: forecast horizon, scalar
    unconditional: boolean, True if unconditional, False if conditional
    verbose: boolean, True if prints of test are needed

    Returns
    -------
    test_stat: test statistic of the conditional predictive ability test
    crit_val: critical value of the chi-square test for a 5% confidence level
    p-val: p-value of the test
    """

    assert len(loss1) == len(loss2)

    lossdiff = loss1 - loss2
    t = len(loss1)
    instruments = np.ones_like(loss1)

    if not unconditional:
        instruments = np.hstack((instruments[:t-tau],
                                 lossdiff[:-tau]))
        lossdiff = lossdiff[tau:]
        t = t - tau

    reg = instruments * lossdiff

    if tau == 1:

        res_beta = np.linalg.solve(reg.T.dot(reg),
                                   reg.T.dot(np.ones((t,1))))
        err = np.ones((t,1)) - reg.dot(res_beta)
        r2 = 1 - np.mean(err**2)
        test_stat = t * r2
        q = reg.shape[1]
        crit_val = chi2.ppf(1-alpha, df=q)
        p_val = 1 - chi2.cdf(np.abs(test_stat), q)

    else:

        zbar = np.mean(reg, axis=0)
        n_lags = tau - 1
        omega = Newey_West(Z=reg, n_lags=n_lags)
        print(omega)
        test_stat = np.expand_dims(t*zbar,
                                   axis=0).dot(np.linalg.inv(omega)).\
                                   dot(zbar)
        q = reg.shape[1]
        crit_val = chi2.ppf(1-alpha, df=q)
        p_val = 1 - chi2.cdf(np.abs(test_stat), q)

    av_diff_loss = np.mean(loss1-loss2)
    s = '+' if np.mean(loss1-loss2) > 0 else '-'

    if verbose:
        if unconditional: print('\nUnconditional test:\n')
        if not unconditional: print('\nConditional test:\n')
        print(f'Forecast horizon: {tau}, Nominal Risk Level: {alpha}')
        print(f'Test-statistic: {test_stat} ({s})')
        print(f'Critical value: {crit_val}')
        print(f'p-value: {p_val}\n')
    return test_stat, crit_val, p_val

# Cell
def GW_test_p_values(y, y_hat, tau, alpha=0.05, unconditional=True):
    """ Plotting function of the GW Test p-values
    Parameters
    ----------
    y: (batch_size,) observed values
    y_hat: (k, batch_size) numpy array with predictions from k different models


    Returns
    -------

    """
    losses = np.abs(y - y_hat)
    k = y_hat.shape[1]
    p_values = np.zeros((k, k))

    for i in range(k):
        for j in range(k):
            if i == j: pass
            else:
                test_stat, crit_val, p_val = \
                    GW_CPA_test(loss1=np.expand_dims(losses[:,i], axis=1),
                                loss2=np.expand_dims(losses[:,j], axis=1),
                                tau=tau, alpha=alpha,
                                unconditional=unconditional,
                                verbose=False)
                p_values[i,j] = p_val

    return p_values


def plot_GW_test_p_values(y, y_hat, model_names,
                          tau, alpha=0.05, unconditional=True,
                          verbose=True, title='GW Test'):

    p_values = GW_test_p_values(y=y, y_hat=y_hat, tau=tau,
                                alpha=0.05, unconditional=True)

    if verbose:
        print(p_values)

    fig, ax = plt.subplots(figsize=(6, 6))

    # # Defining color map
    # red = np.concatenate([np.linspace(0, 1, 50), np.linspace(1, 0.5, 50)[1:], [0]])
    # green = np.concatenate([np.linspace(0.5, 1, 50), np.zeros(50)])
    # blue = np.zeros(100)
    # rgb_color_map = np.concatenate([red.reshape(-1, 1), green.reshape(-1, 1),
    #                                 blue.reshape(-1, 1)], axis=1)
    # rgb_color_map = mpl.colors.ListedColormap(rgb_color_map)

    # Generating figure
    # im = plt.imshow(p_values, cmap=plt.get_cmap('Blues_r'), vmin=0, vmax=0.1)
    im = ax.imshow(p_values, cmap=plt.get_cmap('GnBu_r'), vmin=0, vmax=0.1)
    #im = ax.imshow(p_values, cmap=plt.get_cmap('Blues_r'), alpha=0.8)
    #im = ax.imshow(p_values, cmap=plt.get_cmap('RdYlGn'), alpha=0.3)

    # Ticks and labels
    assert len(model_names) == len(p_values)
    ax.set_xticks(np.arange(len(p_values)))
    ax.set_yticks(np.arange(len(p_values)))

    ax.set_xticklabels(model_names, fontsize=16)
    ax.set_yticklabels(model_names, fontsize=16)

    for i in range(len(model_names)):
        text = ax.text(i, i, 'x',
                       ha="center", va="center", color="w")

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=90,
             ha="right", rotation_mode="anchor")

    # Colorbar
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(im, cax=cax)

    ax.set_title(title, fontsize=17, fontweight='bold')
    fig.tight_layout()
    plt.savefig(f'./results/{title}.pdf', bbox_inches = 'tight')
    plt.show()